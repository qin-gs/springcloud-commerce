#### 微服务

##### 微服务演进过程



**单体架构**：开发部署上线简单；代码耦合严重，修改后需要重新打包部署

<img src="../img/单体架构.png" alt="单体架构" style="zoom:50%;" />

**垂直应用架构**：部署独立，水平扩展容易；搭建复杂，服务之间关系复杂，维护困难

垂直拆分，独立部署，独立数据库，独立的域名去部署

<img src="../img/垂直应用架构.png" alt="垂直应用架构" style="zoom:50%;" />

**SOA 架构**：通过总线提供底层服务的统一入口

<img src="../img/SOA架构.png" alt="SOA 架构" style="zoom:50%;" />

**微服务**

<img src="../img/微服务.png" alt="微服务" style="zoom:50%;" />



##### 微服务架构遵循的原则

- 职责独立，每个微服务只做自己功能范围内的事，微服务之间的依赖链不要太长 (会导致问题追踪困难)
- 使用熔断器实现快速的故障容错 和 线程隔离
- 通过网管代理微服务请求，网关是微服务架构对外暴露的唯一入口
- 确保微服务 api 变更后能够向后兼容



##### 领域驱动设计 (DDD)

一种软件架构设计方法，不定义软件开发过程

利用面向对象的特性，以业务为核心驱动而不是传统数据库驱动开发

领域是对功能需求的划分，大领域下还有小领域

- 分析领域模型，推演实体、值对象、领域服务
- 找出聚合边界 (降低服务耦合)
- 为聚合配备存储仓库 (数据持久化)
- 实践 DDD，不断的推倒重构

<img src="../img/领域驱动设计.png" alt="领域驱动设计" style="zoom:50%;" />

用户接口；应用程序；领域；基础设置层



**电商工程业务解读 微服务模块拆分**

<img src="../img/电商工程业务解读.png" alt="电商工程业务解读" style="zoom:25%;" />

工程入口

<img src="../img/工程入口.png" alt="工程入口" style="zoom:50%;" />

电商功能 (账户，商品，订单，物流)

<img src="../img/电商功能.png" alt="电商功能" style="zoom:50%;" />



#### alibaba nacos

服务，配置服务，名字服务

- 服务注册中心：是服务、实例、元数据的数据库；会调用服务实例的健康检测 api 验证它能否处理请求

- 服务元数据：包括端点、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据
- 服务提供/消费方
- 配置：一些需要变更的参数从代码中分离出来以独立的配置文件的形式存在



单机版本启动：./startup.sh -m standalone

配置自定义 mysql 持久化

```properties
### If use MySQL as datasource:
spring.datasource.platform=mysql

### Count of DB:
db.num=1

### Connect URL of DB:
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=GMT%2B8
db.user.0=root
db.password.0=root

### Connection pool configuration: hikariCP
db.pool.config.connectionTimeout=30000
db.pool.config.validationTimeout=10000
db.pool.config.maximumPoolSize=2
```



##### nacos 集群部署

- 定义集群部署的 ip 和 端口 (cluster.conf)
- 集群必须使用可以共同访问到的数据源作为持久化的方式，需要去数据库中创建表
- 修改 nacos 配置的端口号 application.properties
- 启动 ./startup.sh



##### nacos 服务注册与发现



####  spring-boot-admin 监控

actuator

端点 endpoint

- 应用控制类：自动配置信息，bean信息，yml信息，环境信息

- 度量指标类：运行期信息 (堆栈，健康指标，metrics)

- 操作控制类：shutdown，发送一个请求关闭监控功能



将微服务注册到 admin

- 通过 springboot-admin-client，通过 http 调用注册进去

- 被监控的应用程序注册到注册中心，admin 通过注册中心获取到被监控的应用程序 `@EnableAdminServer`

  ```yaml
  # 如果有上下文路径
  metadata:
    management:
      context-path: ${server.servlet.context-path}/actuator
  ```



监控中心添加安全访问控制

```xml
<!-- 每个微服务都要有-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- springboot admin-->
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-server</artifactId>
    <version>2.2.0</version>
</dependency>
<!-- 开启登录认证功能-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

暴露端点

```yaml
# 暴露端点
management:
  endpoints:
    web:
      exposure:
        include: '*' # 需要开发的端点，默认只打开 health, info
  endpoint:
    health:
      show-details: always
```



#### 基于 jwt 的身份认证授权

| jwt                              | session                            |
| -------------------------------- | ---------------------------------- |
| 直接解析得到用户信息             | 需要数据映射匹配                   |
| 只有过期时间限制                 | 保存在服务器，可控性更强           |
| 任意传播，可以跨服务器           | 需要在一台服务器上解析             |
| 存储在客户端                     | 存储在服务器端，数据量大会造成开销 |
| 生成之后，独立之后存在，难以控制 | 时效性由服务端控制                 |



#### SpringCloud Gateway 网关

所有微服务的统一入口，提供路由方式

- zuul：阻塞io，基于 servlet 2.5，不支持长连接

- gateway：  非阻塞io，spring5，支持websocket



三个组成部分

- 路由 route
- 断言 predicate
- 过滤器 filter



工作模型

- 请求发送到网关，经由分发起将请求匹配到 HandlerMapping
- 请求和处理器之间有一个映射，路由到网关处理程序
- 执行特定的请求过滤器链
- 到达代理的微服务

<img src="../img/网关工作模型.png" alt="网关工作模型" style="zoom:50%;" />

继承 nacos 实现动态路由配置

- 静态路由

  写在配置文件中 (spring.cloud.gateway)，每次修改都要重写部署

- 动态路由

  nacos 中维护，可以动态变更


**注册路由**

- 注入 RouteLocator，手动编写路由配置
- bootstrap.yml 中配置 spring.cloud.gateway
- 通过配置中心 nacos 实现动态路由配置



##### 过滤器

前置处理，后置处理

- 全局过滤器：作用于所有路由

  ```java
  @Component
  public class GlobalCacheRequestBodyFilter implements GlobalFilter, Ordered {
  }
  ```

- 局部过滤器

  ```java
  // 1. 创建一个局部过滤器
  public class HeaderTokenGatewayFilter implements GatewayFilter, Ordered {
  }
  
  // 2. 通过工厂注入进去
  @Component
  public class HeaderTokenGatewayFilterFactory extends AbstractGatewayFilterFactory<Object> {
  
      @Override
      public GatewayFilter apply(Object config) {
          return new HeaderTokenGatewayFilter();
      }
  }
  
  // 3. 添加到配置文件中
  ```




#### SpringCloud zipkin 数据解析



**对 slueth 的数据实现收集解析**，展示完整的请求链路、耗时、依赖等等信息

默认将跟踪信息存储在内存中，重启后丢失

默认使用 http 方式上报跟踪数据，性能较差

配置 mysql 将跟踪数据持久化



#### Brave

- 一个 tracer 库，提供 tracer 接口

  - trace：一个逻辑执行过程中的整个链条

  - span：trace 跟踪的基本单位

- sleuth 采用 Barve 作为 tracer 库

- sleuth 可以不使用 zipkin



常用数据结构

- Tracing：工具类，生成 Tracer 实例
- Tracer：工具类，生成 Span 
- Span：记录每个功能块执行信息
- TraceContext：记录 trace 执行过程中的元数据信息
- Propagation：分布式环境或跨进程条件下 trace 跟踪时实现 TraceContext 传递的工具类



#### SpringCloud sleuth 日志追踪

跨服务 trace 跟踪

- sleuth：自动为当前应用构建各通信信道的跟踪机制

  - 通过 rabbitmq，kafka 等传递的请求
  - 通过 zuul，gateway 代理传递的请求
  - 通过 RestTemplate 发起的请求

  为了实现请求跟踪，当请求发送到分布式系统的入口时，需要服务跟中框架为该请求创建一个跟踪 id

  为了统计各单元的时间延迟，当请求到达各个服务组件 或 处理逻辑到达某个状态时，也通过唯一标记记录它的开始，具体过程 和 结束

- zipkin：实现对跟踪信息的收集

  解决微服务架构中的延迟问题 (数据收集，存储，查找，展现)
  
  - Collector：收集器组件
  - Storage：存储组件
  - api：提供外部访问接口
  - ui：提供可视化查询页面



##### 整合

```shell
# nacos
./bin/startup.cmd -m standalone

# kafka 追踪信息传输
./bin/windows/zookeeper-server-start.bat ./config/zookeeper.properties
./bin/windows/kafka-server-start.bat ./config/server.properties

# zipkin
java -DKAFKA_BOOTSTRAP_SERVERS=127.0.0.1:9092 -jar zipkin-server-2.23.16-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_DB=imooc_zipkin --MYSQL_USER=root --MYSQL_PASS=root

```



##### sleuth 采样率

- ProbabilityBasedSample：采样率策略，默认收集 10% 的请求跟踪信息

- RateLimitingSample：抽样策略 (优先级更高)，限速采集，每秒追踪请求的最大数量

  ```properties
  spring.sleuth.sampler.probability=0.5
  spring.sleuth.sampler.rate=10 # 优先级更高
  ```

  

```
// 请求发起者，trace id， span id， 是否采样
2022-06-01 16:25:01.176  INFO [commerce-authority-center,1b8b5699a0d77e3c,1b8b5699a0d77e3c,true] 11624 --- [nio-7000-exec-3] c.e.c.controller.AuthorityController     : request to get token with params: {"username":"qqq","password":"password"}
```



#### 用户账户微服务



##### 集成 swagger2



```shell
# nacos
/Users/qgs/Downloads/nacos-8848/bin/startup.sh -m standalone

# redis
brew services start redis

# zipkin
java -jar /Users/qgs/Downloads/zipkin-server-2.23.16-exec.jar --STORAGE_TYPE=mysql --MYSQL_HOST=127.0.0.1 --MYSQL_TCP_PORT=3306 --MYSQL_USER=root --MYSQL_PASS=root --MYSQL_DB=imooc_zipkin

# kafka
/Users/qgs/Downloads/kafka_2.13-2.7.0/bin/zookeeper-server-start.sh /Users/qgs/Downloads/kafka_2.13-2.7.0/config/zookeeper.properties

/Users/qgs/Downloads/kafka_2.13-2.7.0/bin/kafka-server-start.sh /Users/qgs/Downloads/kafka_2.13-2.7.0/config/server.properties
```



#### 微服务通信

- RPC：将可用服务放到注册中心，通过传递 方法名，参数等 进行调用
- http (rest)：RestTemplate
- Message：通过消息队列进行消息的发布订阅，可以实现 削峰填谷，缓冲机制实现数据任务缓存；只能做到最终一致性，做不到实时一致性



##### RestTemplate

- 配置文件中写死 ip, port
- 通过注册中心获取服务地址，可以实现负载均衡



##### 微服务通信 SpringCloud Netflix Ribbon 实现

用注册中心中的服务名 代替写死的 host, port ，使用被重写的 RestTemplate 发送请求

```java
// 给 RestTemplate 增加拦截器，在请求之前对请求的地址进行替换，或者根据具体的负载策略选择服务地址，然后再去调用，这就是 @LoadBalanced 的原理
// ClientHttpRequestInterceptor + SmartInitializingSingleton

// org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration
@Bean
@LoadBalanced
public RestTemplate restTemplate() {
    return new RestTemplate();
}
```





##### SpringCloud OpenFeign 组合 ribbon + feign

```
@EnableFeignClients

@FeignClient(value = "commerce-authority-center", contextId = "AuthorityFeignClient")
```

Feign OpenFeign

- 他们底层都是内置了Ribbon，去调用注册中心的服务。
- Feign是Netflix公司写的，是SpringCloud组件中的一个轻量级RESTful的HTTP服务客户端，是SpringCloud中的第一代负载均衡客户端。
- OpenFeign是SpringCloud自己研发的，在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。是SpringCloud中的第二代负载均衡客户端。
- Feign本身不支持Spring MVC的注解，使用Feign的注解定义接口，调用这个接口，就可以调用服务注册中心的服务
- OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。



#### SpringCloud Netflix Hystrix 服务容错

故障隔离

- 通过添加 延迟容忍 和 容错逻辑，控制分布式服务之间的交互
- 通过隔离服务之间的访问点，停止级联服务，通过回退选项 提供服务之间的容错
- 目标
  - 对客户端的延迟 和 故障 进行保护控制
  - 在复杂的分布式系统中阻止级联故障
  - 快速失败，快速恢复
  - 兜底回退，尽可能优雅降级



下游服务出现错误超时问题时，让客户端快速失败，不消耗当前服务的数据库连接、线程池等资源，保证当前服务不会被下游服务拖垮



**Hystrix 完整的工作流程**

- 构造一个 `HystrixCommand` 或者 `HystrixObservableCommand` 对象

- 执行命令获取响应

  - execute：同步阻塞,直到收到响应或者抛出异常

  - queue：异步返回一个Future

  - observe：订阅代表响应的 Observable

  - toObservable：返回一个Observable ,当你订阅它以后,将会执行 Hystrix 命令并且推送它的响应

- 判断
  - 响应是否被缓存
  - 断路器是否打开 (打开后直接 fallback)
  - 线程池，信号量是否使用了 100%
- 执行
  - com.netflix.hystrix.HystrixCommand#run 只能返回单条数据
  - com.netflix.hystrix.HystrixObservableCommand#construct 可以返回多条数据
- 计算电路健康
- 回退 或 返回成功响应



##### 服务容错

三种模式

- 断路器模式：设置超时 或 失败等 熔断策略

- 后备策略模式：断路器模式触发后，执行后备策略

- 舱壁模式：为每个服务分别指定线程池 或 使用信号量完成；可以通过代码 和 注解完成功能

  - 线程池

    ```java
    // 通过 HystrixObservableCommand 接口完成
    public class NacosClientHystrixObservableCommand extends HystrixObservableCommand<List<ServiceInstance>>
    ```

    

  - 信号量

    ```java
    // 通过 HystrixCommand 完成
    public class NacosClientHystrixCommand extends HystrixCommand<List<ServiceInstance>>
    ```

    

##### 请求缓存

将结果缓存到上下文中

- 代码

  初始化 hystrix 请求上下文

  重写 com.netflix.hystrix.AbstractCommand#getCacheKey

- 注解

  初始化 hystrix 请求上下文

  ```java
  // @CacheResult：方法的返回值会被缓存，需要与 @HystrixCommand 一起使用
  // @CacheRemove：让缓存失效
  // @CacheKey：标记为 key (默认将方法的所有入参作为 key)
  
  @CacheResult
  @HystrixCommand(commandKey = "CacheHystrixCommandAnnotation")
  public List<ServiceInstance> useCacheByAnnotation2(@CacheKey String serviceId) {
      log.info("02. serviceId: {}", serviceId);
      return nacosClientService.getNacosInfo(serviceId);
  }
  @CacheRemove(commandKey = "CacheHystrixCommandAnnotation")
  @HystrixCommand
  public void flushCacheByAnnotation2(@CacheKey String cacheId) {
      log.info("02. 清除缓存: {}", cacheId);
  }
  ```

  

##### 请求合并

适用场景：单个对象的查询并发数很高,服务提供方负载较，就可以考虑使用请求合并

注意事项.

- 请求在代码中人为的设置了延迟时间,会降低请求的响应速度

- 可能会提高服务提供方的负载,因为返回List结果数据量偏大

- 实现请求合并比较复杂



##### 后备模式

组合 openFeign，Hystrix



##### Dashboard 监控客户端容错





#### 消息驱动微服务

Spring Messaging：统一消息的编程模型

将消息抽象为 `org.springframework.messaging.Message` = header + payload



##### SpringCloud Stream

![消息驱动](../img/消息驱动微服务.png)



![SpringCloud Stream 架构](../img/SpringCloud Stream 架构.png)



- Binder：与中间件交互(通信)的抽象绑定器，屏蔽底层中间件的使用细节
- IO：发送消息与接送消息的应用通信信道

发布订阅模型

- topic：
- producer：
- consumer：



##### 自定义通道

发送接收消息

- 默认通道

- 自定义通道



##### 消息分组

- 应用的不同实例放在一个消费者组中，每一条消息只会被一个实例消费
- 消费者组的思想时通过多实例扩展服务吞吐量，不会造成消息的重复消费



##### 消费分区

- 作用：确保具有共同**特征**标识的数据由同一个消费者实例进行处理

<img src="../img/消息分区.png" alt="消息分区" style="zoom:80%;" />















