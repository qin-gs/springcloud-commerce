#### 微服务演进过程

**单体架构**：开发部署上线简单；代码耦合严重，修改后需要重新打包部署

<img src="../img/单体架构.png" alt="单体架构" style="zoom:50%;" />

**垂直应用架构**：部署独立，水平扩展容易；搭建复杂，服务之间关系复杂，维护困难

垂直拆分，独立部署，独立数据库，独立的域名去部署

<img src="../img/垂直应用架构.png" alt="垂直应用架构" style="zoom:50%;" />

**SOA 架构**：通过总线提供底层服务的统一入口

<img src="../img/SOA架构.png" alt="SOA 架构" style="zoom:50%;" />

**微服务**

<img src="../img/微服务.png" alt="微服务" style="zoom:50%;" />



#### 微服务架构遵循的原则

- 职责独立，每个微服务只做自己功能范围内的事，微服务之间的依赖链不要太长 (会导致问题追踪困难)
- 使用熔断器实现快速的故障容错 和 线程隔离
- 通过网管代理微服务请求，网关是微服务架构对外暴露的唯一入口
- 确保微服务 api 变更后能够向后兼容



#### 领域驱动设计 (DDD)

一种软件架构设计方法，不定义软件开发过程

利用面向对象的特性，以业务为核心驱动而不是传统数据库驱动开发

领域是对功能需求的划分，大领域下还有小领域

- 分析领域模型，推演实体、值对象、领域服务
- 找出聚合边界 (降低服务耦合)
- 为聚合配备存储仓库 (数据持久化)
- 实践 DDD，不断的推倒重构

<img src="../img/领域驱动设计.png" alt="领域驱动设计" style="zoom:50%;" />

用户接口；应用程序；领域；基础设置层



**电商工程业务解读 微服务模块拆分**

<img src="../img/电商工程业务解读.png" alt="电商工程业务解读" style="zoom:25%;" />

工程入口

<img src="../img/工程入口.png" alt="工程入口" style="zoom:50%;" />

电商功能 (账户，商品，订单，物流)

<img src="../img/电商功能.png" alt="电商功能" style="zoom:50%;" />



#### alibaba nacos

服务，配置服务，名字服务

- 服务注册中心：是服务、实例、元数据的数据库；会调用服务实例的健康检测 api 验证它能否处理请求

- 服务元数据：包括端点、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据
- 服务提供/消费方
- 配置：一些需要变更的参数从代码中分离出来以独立的配置文件的形式存在



单机版本启动：./startup.sh -m standalone

配置自定义 mysql 持久化

```properties
### If use MySQL as datasource:
spring.datasource.platform=mysql

### Count of DB:
db.num=1

### Connect URL of DB:
db.url.0=jdbc:mysql://127.0.0.1:3306/nacos_config?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC
db.user.0=root
db.password.0=root

### Connection pool configuration: hikariCP
db.pool.config.connectionTimeout=30000
db.pool.config.validationTimeout=10000
db.pool.config.maximumPoolSize=2
```



#### 集群部署

- 定义集群部署的 ip 和 端口 (cluster.conf)
- 集群必须使用可以共同访问到的数据源作为持久化的方式，需要去数据库中创建表
- 修改 nacos 配置的端口号 application.properties
- 启动 ./startup.sh



##### nacos 服务注册与发现



#### 监控  spring-boot-admin

actuator

端点 endpoint

- 应用控制类：自动配置信息，bean信息，yml信息，环境信息

- 度量指标类：运行期信息 (堆栈，健康指标，metrics)

- 操作控制类：shutdown，发送一个请求关闭监控功能



将微服务注册到 admin

- 通过 springboot-admin-client，通过 http 调用注册进去

- 被监控的应用程序注册到注册中心，admin 通过注册中心获取到被监控的应用程序 `@EnableAdminServer`

  ```yaml
  # 如果有上下文路径
  metadata:
    management:
      context-path: ${server.servlet.context-path}/actuator
  ```



监控中心添加安全访问控制

```xml
<!-- 每个微服务都要有-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
<!-- springboot admin-->
<dependency>
    <groupId>de.codecentric</groupId>
    <artifactId>spring-boot-admin-starter-server</artifactId>
    <version>2.2.0</version>
</dependency>
<!-- 开启登录认证功能-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

暴露端点

```yaml
# 暴露端点
management:
  endpoints:
    web:
      exposure:
        include: '*' # 需要开发的端点，默认只打开 health, info
  endpoint:
    health:
      show-details: always
```



#### 基于 jwt 的身份认证授权

| jwt                              | session                            |
| -------------------------------- | ---------------------------------- |
| 直接解析得到用户信息             | 需要数据映射匹配                   |
| 只有过期时间限制                 | 保存在服务器，可控性更强           |
| 任意传播，可以跨服务器           | 需要在一台服务器上解析             |
| 存储在客户端                     | 存储在服务器端，数据量大会造成开销 |
| 生成之后，独立之后存在，难以控制 | 时效性由服务端控制                 |



#### 网关 gateway 

- 路由 Route
- 断言：Pridicate
- 过滤器：Filter



微服务的唯一入口，提供路由方式

- zuul：阻塞io，基于 servlet 2.5，不支持长连接

- gateway：  非阻塞io，spring5，支持websocket



**注册路由**

- 注入 RouteLocator，手动编写路由配置
- bootstrap.yml 中配置 spring.cloud.gateway
- 通过配置中心 nacos 实现动态路由配置



##### 过滤器

前置处理，后置处理

- 全局过滤器：作用于所有路由

  ```java
  @Component
  public class GlobalCacheRequestBodyFilter implements GlobalFilter, Ordered {
  }
  ```

- 局部过滤器

  ```java
  // 1. 创建一个局部过滤器
  public class HeaderTokenGatewayFilter implements GatewayFilter, Ordered {
  }
  
  // 2. 通过工厂注入进去
  @Component
  public class HeaderTokenGatewayFilterFactory extends AbstractGatewayFilterFactory<Object> {
  
      @Override
      public GatewayFilter apply(Object config) {
          return new HeaderTokenGatewayFilter();
      }
  }
  
  // 3. 添加到配置文件中
  ```

  


